<!-- 
Nathan Le
nle45@ucsc.edu
-->

<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title></title>
        <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
        </style>
    </head>
    <body>
    <canvas id="c"></canvas>
    </body>
    <script  type="importmap">{
        "imports": {
        "three": "https://threejs.org/build/three.module.js",
        "three/addons/": "https://threejs.org/examples/jsm/"
        }
    }
    </script>
    <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { GUI } from "three/addons/libs/lil-gui.module.min.js";
    import { RectAreaLightUniformsLib } from "three/addons/lights/RectAreaLightUniformsLib.js";
    import { RectAreaLightHelper } from "three/addons/helpers/RectAreaLightHelper.js";

    const objLoader = new OBJLoader();
    const gltfLoader = new GLTFLoader();
    const textureLoader = new THREE.TextureLoader();

    function main() {
        const canvas = document.querySelector("#c");
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
        renderer.outputColorSpace = THREE.SRGBColorSpace;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const fov = 45;
        const aspect = 2;
        const near = 0.001;
        const far = 100;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(15, 12, 15);

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 0, 0);

        const scene = new THREE.Scene();

        {
            const spotlight = new THREE.SpotLight(0xe6fffe, 1000, 50, degToRad(40), 0.3);

            spotlight.position.set(-5, 10, 15);
            spotlight.castShadow = true;

            scene.add(spotlight);
        }

        {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);

            scene.add(ambientLight);
        }

        {
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 15);
            directionalLight.castShadow = true;

            scene.add(directionalLight);
        }

        {
            const groundGeometry = new THREE.PlaneGeometry(100, 100, 32, 32);
            groundGeometry.rotateX(-Math.PI / 2);
            const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x555555,
            side: THREE.DoubleSide,
            });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.castShadow = false;
            groundMesh.receiveShadow = true;
            groundMesh.position.set(0, 0, 0);
            scene.add(groundMesh);
        }

        {
            textureLoader.load("./skybox.jpg", (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.colorSpace = THREE.SRGBColorSpace;
            scene.background = texture;
            });
        }
        
        // Airplane by Poly by Google [CC-BY] via Poly Pizza
        {
            gltfLoader.load("Airplane.glb", (gltf) => {
            const mesh = gltf.scene;
            mesh.scale.set(0.25, 0.25, 0.25);

            mesh.traverse((child) => {
                if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                }
            });

            mesh.position.set(0, 0, 0);
            scene.add(mesh);
            });
        }

        function resizeRendererToDisplaySize(renderer) {
            const canvas = renderer.domElement;
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
            renderer.setSize(width, height, false);
            }
            return needResize;
        }

        function render() {
            if (resizeRendererToDisplaySize(renderer)) {
            const canvas = renderer.domElement;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            }
            controls.update();
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        }

        function degToRad(degrees) {
            return (degrees * Math.PI) / 180;
        }

        requestAnimationFrame(render);
        }

        main();
    </script>
  </body>
</html>